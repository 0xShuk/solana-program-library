/**
 * This code was GENERATED using the solita package.
 * Please DO NOT EDIT THIS FILE, instead rerun solita to update it or write a wrapper to add functionality.
 *
 * See: https://github.com/metaplex-foundation/solita
 */

import * as beet from '@metaplex-foundation/beet'
import * as web3 from '@solana/web3.js'
import { Vote, voteBeet } from '../types/Vote'

/**
 * @category Instructions
 * @category CastVote
 * @category generated
 */
export type CastVoteInstructionArgs = {
  vote: Vote
}
/**
 * @category Instructions
 * @category CastVote
 * @category generated
 */
export const CastVoteStruct = new beet.FixableBeetArgsStruct<
  CastVoteInstructionArgs & {
    instructionDiscriminator: number
  }
>(
  [
    ['instructionDiscriminator', beet.u8],
    ['vote', voteBeet],
  ],
  'CastVoteInstructionArgs'
)
/**
  * Accounts required by the _CastVote_ instruction
 *
  * @property [_writable_] realmAccount  
* @property [_writable_] governanceAccount  
* @property [_writable_] proposalAccount  
* @property [_writable_] proposalTokenOwnerRecord TokenOwnerRecord of the Proposal owner 
* @property [_writable_] voterTokenOwnerRecord TokenOwnerRecord of the voter. PDA seeds: ['governance',realm, vote_governing_token_mint, governing_token_owner] 
* @property [**signer**] governanceAuthority Governance Authority (Token Owner or Governance Delegate) 
* @property [_writable_] proposalVoteRecord Proposal VoteRecord account. PDA seeds: ['governance',proposal,token_owner_record] 
* @property [] governingTokenMint The Governing Token Mint which is used to cast the vote (vote_governing_token_mint).
    The voting token mint is the governing_token_mint of the Proposal for Approve, Deny and Abstain votes.
    For Veto vote the voting token mint is the mint of the opposite voting population.
    Council mint to veto Community proposals and Community mint to veto Council proposals
    Note: In the current version only Council veto is supported 
* @property [**signer**] payer  
* @property [] realmConfigAccount RealmConfig account. PDA seeds: ['realm-config', realm] 
* @property [] voterWeightRecord (optional) Optional Voter Weight Record 
* @property [] maxVoterWeightRecord (optional) Optional Max Voter Weight Record  
  * @category Instructions
  * @category CastVote
  * @category generated
  */
export type CastVoteInstructionAccounts = {
  realmAccount: web3.PublicKey
  governanceAccount: web3.PublicKey
  proposalAccount: web3.PublicKey
  proposalTokenOwnerRecord: web3.PublicKey
  voterTokenOwnerRecord: web3.PublicKey
  governanceAuthority: web3.PublicKey
  proposalVoteRecord: web3.PublicKey
  governingTokenMint: web3.PublicKey
  payer: web3.PublicKey
  systemProgram?: web3.PublicKey
  realmConfigAccount: web3.PublicKey
  voterWeightRecord?: web3.PublicKey
  maxVoterWeightRecord?: web3.PublicKey
}

export const castVoteInstructionDiscriminator = 13

/**
 * Creates a _CastVote_ instruction.
 *
 * @param accounts that will be accessed while the instruction is processed
 * @param args to provide as instruction data to the program
 *
 * @category Instructions
 * @category CastVote
 * @category generated
 */
export function createCastVoteInstruction(
  accounts: CastVoteInstructionAccounts,
  args: CastVoteInstructionArgs,
  programId = new web3.PublicKey('GovER5Lthms3bLBqWub97yVrMmEogzX7xNjdXpPPCVZw')
) {
  const [data] = CastVoteStruct.serialize({
    instructionDiscriminator: castVoteInstructionDiscriminator,
    ...args,
  })
  const keys: web3.AccountMeta[] = [
    {
      pubkey: accounts.realmAccount,
      isWritable: true,
      isSigner: false,
    },
    {
      pubkey: accounts.governanceAccount,
      isWritable: true,
      isSigner: false,
    },
    {
      pubkey: accounts.proposalAccount,
      isWritable: true,
      isSigner: false,
    },
    {
      pubkey: accounts.proposalTokenOwnerRecord,
      isWritable: true,
      isSigner: false,
    },
    {
      pubkey: accounts.voterTokenOwnerRecord,
      isWritable: true,
      isSigner: false,
    },
    {
      pubkey: accounts.governanceAuthority,
      isWritable: false,
      isSigner: true,
    },
    {
      pubkey: accounts.proposalVoteRecord,
      isWritable: true,
      isSigner: false,
    },
    {
      pubkey: accounts.governingTokenMint,
      isWritable: false,
      isSigner: false,
    },
    {
      pubkey: accounts.payer,
      isWritable: false,
      isSigner: true,
    },
    {
      pubkey: accounts.systemProgram ?? web3.SystemProgram.programId,
      isWritable: false,
      isSigner: false,
    },
    {
      pubkey: accounts.realmConfigAccount,
      isWritable: false,
      isSigner: false,
    },
  ]

  if (accounts.voterWeightRecord != null) {
    keys.push({
      pubkey: accounts.voterWeightRecord,
      isWritable: false,
      isSigner: false,
    })
  }

  if (accounts.maxVoterWeightRecord != null) {
    if (accounts.voterWeightRecord == null) {
      throw new Error(
        "When providing 'maxVoterWeightRecord' then 'accounts.voterWeightRecord' need(s) to be provided as well."
      )
    }
    keys.push({
      pubkey: accounts.maxVoterWeightRecord,
      isWritable: false,
      isSigner: false,
    })
  }

  const ix = new web3.TransactionInstruction({
    programId,
    keys,
    data,
  })
  return ix
}
